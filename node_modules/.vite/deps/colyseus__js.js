import {
  require_umd
} from "./chunk-VUDMOB4A.js";
import {
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-LREKTYKM.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-4B2QHNJT.js";

// ../node_modules/colyseus.js/build/cjs/legacy.js
var require_legacy = __commonJS({
  "../node_modules/colyseus.js/build/cjs/legacy.js"() {
    "use strict";
    if (!ArrayBuffer.isView) {
      ArrayBuffer.isView = (a) => {
        return a !== null && typeof a === "object" && a.buffer instanceof ArrayBuffer;
      };
    }
    if (typeof globalThis === "undefined" && typeof window !== "undefined") {
      window["globalThis"] = window;
    }
    if (typeof FormData === "undefined") {
      globalThis["FormData"] = class {
      };
    }
  }
});

// ../node_modules/colyseus.js/build/cjs/errors/Errors.js
var require_Errors = __commonJS({
  "../node_modules/colyseus.js/build/cjs/errors/Errors.js"(exports) {
    "use strict";
    exports.CloseCode = void 0;
    (function(CloseCode) {
      CloseCode[CloseCode["CONSENTED"] = 4e3] = "CONSENTED";
      CloseCode[CloseCode["DEVMODE_RESTART"] = 4010] = "DEVMODE_RESTART";
    })(exports.CloseCode || (exports.CloseCode = {}));
    var ServerError = class extends Error {
      constructor(code, message) {
        super(message);
        this.name = "ServerError";
        this.code = code;
      }
    };
    var AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports.AbortError = AbortError;
    exports.ServerError = ServerError;
  }
});

// ../node_modules/colyseus.js/build/cjs/transport/H3Transport.js
var require_H3Transport = __commonJS({
  "../node_modules/colyseus.js/build/cjs/transport/H3Transport.js"(exports) {
    "use strict";
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var schema = require_umd();
    var H3TransportTransport = class {
      constructor(events) {
        this.events = events;
        this.isOpen = false;
        this.lengthPrefixBuffer = new Uint8Array(9);
      }
      connect(url, options = {}) {
        const wtOpts = options.fingerprint && {
          // requireUnreliable: true,
          // congestionControl: "default", // "low-latency" || "throughput"
          serverCertificateHashes: [{
            algorithm: "sha-256",
            value: new Uint8Array(options.fingerprint).buffer
          }]
        } || void 0;
        this.wt = new WebTransport(url, wtOpts);
        this.wt.ready.then((e) => {
          console.log("WebTransport ready!", e);
          this.isOpen = true;
          this.unreliableReader = this.wt.datagrams.readable.getReader();
          this.unreliableWriter = this.wt.datagrams.writable.getWriter();
          const incomingBidi = this.wt.incomingBidirectionalStreams.getReader();
          incomingBidi.read().then((stream) => {
            this.reader = stream.value.readable.getReader();
            this.writer = stream.value.writable.getWriter();
            this.sendSeatReservation(options.room.roomId, options.sessionId, options.reconnectionToken);
            this.readIncomingData();
            this.readIncomingUnreliableData();
          }).catch((e2) => {
            console.error("failed to read incoming stream", e2);
            console.error("TODO: close the connection");
          });
        }).catch((e) => {
          console.log("WebTransport not ready!", e);
          this._close();
        });
        this.wt.closed.then((e) => {
          console.log("WebTransport closed w/ success", e);
          this.events.onclose({ code: e.closeCode, reason: e.reason });
        }).catch((e) => {
          console.log("WebTransport closed w/ error", e);
          this.events.onerror(e);
          this.events.onclose({ code: e.closeCode, reason: e.reason });
        }).finally(() => {
          this._close();
        });
      }
      send(data) {
        const prefixLength = schema.encode.number(this.lengthPrefixBuffer, data.length, { offset: 0 });
        const dataWithPrefixedLength = new Uint8Array(prefixLength + data.length);
        dataWithPrefixedLength.set(this.lengthPrefixBuffer.subarray(0, prefixLength), 0);
        dataWithPrefixedLength.set(data, prefixLength);
        this.writer.write(dataWithPrefixedLength);
      }
      sendUnreliable(data) {
        const prefixLength = schema.encode.number(this.lengthPrefixBuffer, data.length, { offset: 0 });
        const dataWithPrefixedLength = new Uint8Array(prefixLength + data.length);
        dataWithPrefixedLength.set(this.lengthPrefixBuffer.subarray(0, prefixLength), 0);
        dataWithPrefixedLength.set(data, prefixLength);
        this.unreliableWriter.write(dataWithPrefixedLength);
      }
      close(code, reason) {
        try {
          this.wt.close({ closeCode: code, reason });
        } catch (e) {
          console.error(e);
        }
      }
      readIncomingData() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          let result;
          while (this.isOpen) {
            try {
              result = yield this.reader.read();
              const messages = result.value;
              const it = { offset: 0 };
              do {
                const length = schema.decode.number(messages, it);
                this.events.onmessage({ data: messages.subarray(it.offset, it.offset + length) });
                it.offset += length;
              } while (it.offset < messages.length);
            } catch (e) {
              if (e.message.indexOf("session is closed") === -1) {
                console.error("H3Transport: failed to read incoming data", e);
              }
              break;
            }
            if (result.done) {
              break;
            }
          }
        });
      }
      readIncomingUnreliableData() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          let result;
          while (this.isOpen) {
            try {
              result = yield this.unreliableReader.read();
              const messages = result.value;
              const it = { offset: 0 };
              do {
                const length = schema.decode.number(messages, it);
                this.events.onmessage({ data: messages.subarray(it.offset, it.offset + length) });
                it.offset += length;
              } while (it.offset < messages.length);
            } catch (e) {
              if (e.message.indexOf("session is closed") === -1) {
                console.error("H3Transport: failed to read incoming data", e);
              }
              break;
            }
            if (result.done) {
              break;
            }
          }
        });
      }
      sendSeatReservation(roomId, sessionId, reconnectionToken) {
        const it = { offset: 0 };
        const bytes = [];
        schema.encode.string(bytes, roomId, it);
        schema.encode.string(bytes, sessionId, it);
        if (reconnectionToken) {
          schema.encode.string(bytes, reconnectionToken, it);
        }
        this.writer.write(new Uint8Array(bytes).buffer);
      }
      _close() {
        this.isOpen = false;
      }
    };
    exports.H3TransportTransport = H3TransportTransport;
  }
});

// ../node_modules/ws/browser.js
var require_browser = __commonJS({
  "../node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// ../node_modules/colyseus.js/build/cjs/transport/WebSocketTransport.js
var require_WebSocketTransport = __commonJS({
  "../node_modules/colyseus.js/build/cjs/transport/WebSocketTransport.js"(exports) {
    "use strict";
    var NodeWebSocket = require_browser();
    var WebSocket = globalThis.WebSocket || NodeWebSocket;
    var WebSocketTransport = class {
      constructor(events) {
        this.events = events;
      }
      send(data) {
        this.ws.send(data);
      }
      sendUnreliable(data) {
        console.warn("colyseus.js: The WebSocket transport does not support unreliable messages");
      }
      /**
       * @param url URL to connect to
       * @param headers custom headers to send with the connection (only supported in Node.js. Web Browsers do not allow setting custom headers)
       */
      connect(url, headers) {
        try {
          this.ws = new WebSocket(url, { headers, protocols: this.protocols });
        } catch (e) {
          this.ws = new WebSocket(url, this.protocols);
        }
        this.ws.binaryType = "arraybuffer";
        this.ws.onopen = this.events.onopen;
        this.ws.onmessage = this.events.onmessage;
        this.ws.onclose = this.events.onclose;
        this.ws.onerror = this.events.onerror;
      }
      close(code, reason) {
        this.ws.close(code, reason);
      }
      get isOpen() {
        return this.ws.readyState === WebSocket.OPEN;
      }
    };
    exports.WebSocketTransport = WebSocketTransport;
  }
});

// ../node_modules/colyseus.js/build/cjs/Connection.js
var require_Connection = __commonJS({
  "../node_modules/colyseus.js/build/cjs/Connection.js"(exports) {
    "use strict";
    var H3Transport = require_H3Transport();
    var WebSocketTransport = require_WebSocketTransport();
    var Connection = class {
      constructor(protocol) {
        this.events = {};
        switch (protocol) {
          case "h3":
            this.transport = new H3Transport.H3TransportTransport(this.events);
            break;
          default:
            this.transport = new WebSocketTransport.WebSocketTransport(this.events);
            break;
        }
      }
      connect(url, options) {
        this.transport.connect.call(this.transport, url, options);
      }
      send(data) {
        this.transport.send(data);
      }
      sendUnreliable(data) {
        this.transport.sendUnreliable(data);
      }
      close(code, reason) {
        this.transport.close(code, reason);
      }
      get isOpen() {
        return this.transport.isOpen;
      }
    };
    exports.Connection = Connection;
  }
});

// ../node_modules/colyseus.js/build/cjs/Protocol.js
var require_Protocol = __commonJS({
  "../node_modules/colyseus.js/build/cjs/Protocol.js"(exports) {
    "use strict";
    exports.Protocol = void 0;
    (function(Protocol) {
      Protocol[Protocol["HANDSHAKE"] = 9] = "HANDSHAKE";
      Protocol[Protocol["JOIN_ROOM"] = 10] = "JOIN_ROOM";
      Protocol[Protocol["ERROR"] = 11] = "ERROR";
      Protocol[Protocol["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
      Protocol[Protocol["ROOM_DATA"] = 13] = "ROOM_DATA";
      Protocol[Protocol["ROOM_STATE"] = 14] = "ROOM_STATE";
      Protocol[Protocol["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
      Protocol[Protocol["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
      Protocol[Protocol["ROOM_DATA_BYTES"] = 17] = "ROOM_DATA_BYTES";
    })(exports.Protocol || (exports.Protocol = {}));
    exports.ErrorCode = void 0;
    (function(ErrorCode) {
      ErrorCode[ErrorCode["MATCHMAKE_NO_HANDLER"] = 4210] = "MATCHMAKE_NO_HANDLER";
      ErrorCode[ErrorCode["MATCHMAKE_INVALID_CRITERIA"] = 4211] = "MATCHMAKE_INVALID_CRITERIA";
      ErrorCode[ErrorCode["MATCHMAKE_INVALID_ROOM_ID"] = 4212] = "MATCHMAKE_INVALID_ROOM_ID";
      ErrorCode[ErrorCode["MATCHMAKE_UNHANDLED"] = 4213] = "MATCHMAKE_UNHANDLED";
      ErrorCode[ErrorCode["MATCHMAKE_EXPIRED"] = 4214] = "MATCHMAKE_EXPIRED";
      ErrorCode[ErrorCode["AUTH_FAILED"] = 4215] = "AUTH_FAILED";
      ErrorCode[ErrorCode["APPLICATION_ERROR"] = 4216] = "APPLICATION_ERROR";
    })(exports.ErrorCode || (exports.ErrorCode = {}));
  }
});

// ../node_modules/colyseus.js/build/cjs/serializer/Serializer.js
var require_Serializer = __commonJS({
  "../node_modules/colyseus.js/build/cjs/serializer/Serializer.js"(exports) {
    "use strict";
    var serializers = {};
    function registerSerializer(id, serializer) {
      serializers[id] = serializer;
    }
    function getSerializer(id) {
      const serializer = serializers[id];
      if (!serializer) {
        throw new Error("missing serializer: " + id);
      }
      return serializer;
    }
    exports.getSerializer = getSerializer;
    exports.registerSerializer = registerSerializer;
  }
});

// ../node_modules/colyseus.js/build/cjs/core/nanoevents.js
var require_nanoevents = __commonJS({
  "../node_modules/colyseus.js/build/cjs/core/nanoevents.js"(exports) {
    "use strict";
    var createNanoEvents = () => ({
      emit(event, ...args) {
        let callbacks = this.events[event] || [];
        for (let i = 0, length = callbacks.length; i < length; i++) {
          callbacks[i](...args);
        }
      },
      events: {},
      on(event, cb) {
        var _a;
        ((_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(cb)) || (this.events[event] = [cb]);
        return () => {
          var _a2;
          this.events[event] = (_a2 = this.events[event]) === null || _a2 === void 0 ? void 0 : _a2.filter((i) => cb !== i);
        };
      }
    });
    exports.createNanoEvents = createNanoEvents;
  }
});

// ../node_modules/colyseus.js/build/cjs/core/signal.js
var require_signal = __commonJS({
  "../node_modules/colyseus.js/build/cjs/core/signal.js"(exports) {
    "use strict";
    var EventEmitter = class {
      constructor() {
        this.handlers = [];
      }
      register(cb, once = false) {
        this.handlers.push(cb);
        return this;
      }
      invoke(...args) {
        this.handlers.forEach((handler) => handler.apply(this, args));
      }
      invokeAsync(...args) {
        return Promise.all(this.handlers.map((handler) => handler.apply(this, args)));
      }
      remove(cb) {
        const index = this.handlers.indexOf(cb);
        this.handlers[index] = this.handlers[this.handlers.length - 1];
        this.handlers.pop();
      }
      clear() {
        this.handlers = [];
      }
    };
    function createSignal() {
      const emitter = new EventEmitter();
      function register(cb) {
        return emitter.register(cb, this === null);
      }
      register.once = (cb) => {
        const callback = function(...args) {
          cb.apply(this, args);
          emitter.remove(callback);
        };
        emitter.register(callback);
      };
      register.remove = (cb) => emitter.remove(cb);
      register.invoke = (...args) => emitter.invoke(...args);
      register.invokeAsync = (...args) => emitter.invokeAsync(...args);
      register.clear = () => emitter.clear();
      return register;
    }
    exports.EventEmitter = EventEmitter;
    exports.createSignal = createSignal;
  }
});

// ../node_modules/colyseus.js/build/cjs/serializer/SchemaSerializer.js
var require_SchemaSerializer = __commonJS({
  "../node_modules/colyseus.js/build/cjs/serializer/SchemaSerializer.js"(exports) {
    "use strict";
    var schema = require_umd();
    function getStateCallbacks(room) {
      try {
        return schema.getDecoderStateCallbacks(room["serializer"].decoder);
      } catch (e) {
        return void 0;
      }
    }
    var SchemaSerializer = class {
      setState(encodedState, it) {
        this.decoder.decode(encodedState, it);
      }
      getState() {
        return this.state;
      }
      patch(patches, it) {
        return this.decoder.decode(patches, it);
      }
      teardown() {
        this.decoder.root.clearRefs();
      }
      handshake(bytes, it) {
        if (this.state) {
          schema.Reflection.decode(bytes, it);
          this.decoder = new schema.Decoder(this.state);
        } else {
          this.decoder = schema.Reflection.decode(bytes, it);
          this.state = this.decoder.state;
        }
      }
    };
    exports.SchemaSerializer = SchemaSerializer;
    exports.getStateCallbacks = getStateCallbacks;
  }
});

// ../node_modules/@colyseus/msgpackr/unpack.js
function checkedRead(options) {
  try {
    if (!currentUnpackr.trusted && !sequentialMode) {
      let sharedLength = currentStructures.sharedLength || 0;
      if (sharedLength < currentStructures.length)
        currentStructures.length = sharedLength;
    }
    let result;
    if (currentUnpackr.randomAccessStructure && src[position] < 64 && src[position] >= 32 && readStruct) {
      result = readStruct(src, position, srcEnd, currentUnpackr);
      src = null;
      if (!(options && options.lazy) && result)
        result = result.toJSON();
      position = srcEnd;
    } else
      result = read();
    if (bundledStrings) {
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (sequentialMode)
      currentStructures.restoreStructures = null;
    if (position == srcEnd) {
      if (currentStructures && currentStructures.restoreStructures)
        restoreStructures();
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      throw new Error("Unexpected end of MessagePack data");
    } else if (!sequentialMode) {
      let jsonView;
      try {
        jsonView = JSON.stringify(result, (_, value) => typeof value === "bigint" ? `${value}n` : value).slice(0, 100);
      } catch (error) {
        jsonView = "(JSON view not available " + error + ")";
      }
      throw new Error("Data read, but end of buffer not reached " + jsonView);
    }
    return result;
  } catch (error) {
    if (currentStructures && currentStructures.restoreStructures)
      restoreStructures();
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer") || position > srcEnd) {
      error.incomplete = true;
    }
    throw error;
  }
}
function restoreStructures() {
  for (let id in currentStructures.restoreStructures) {
    currentStructures[id] = currentStructures.restoreStructures[id];
  }
  currentStructures.restoreStructures = null;
}
function read() {
  let token = src[position++];
  if (token < 160) {
    if (token < 128) {
      if (token < 64)
        return token;
      else {
        let structure = currentStructures[token & 63] || currentUnpackr.getStructures && loadStructures()[token & 63];
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure, token & 63);
          }
          return structure.read();
        } else
          return token;
      }
    } else if (token < 144) {
      token -= 128;
      if (currentUnpackr.mapsAsObjects) {
        let object = {};
        for (let i = 0; i < token; i++) {
          let key = readKey();
          if (key === "__proto__")
            key = "__proto_";
          object[key] = read();
        }
        return object;
      } else {
        let map = /* @__PURE__ */ new Map();
        for (let i = 0; i < token; i++) {
          map.set(read(), read());
        }
        return map;
      }
    } else {
      token -= 144;
      let array = new Array(token);
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      if (currentUnpackr.freezeData)
        return Object.freeze(array);
      return array;
    }
  } else if (token < 192) {
    let length = token - 160;
    if (srcStringEnd >= position) {
      return srcString.slice(position - srcStringStart, (position += length) - srcStringStart);
    }
    if (srcStringEnd == 0 && srcEnd < 140) {
      let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);
      if (string != null)
        return string;
    }
    return readFixedString(length);
  } else {
    let value;
    switch (token) {
      case 192:
        return null;
      case 193:
        if (bundledStrings) {
          value = read();
          if (value > 0)
            return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
          else
            return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value);
        }
        return C1;
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        value = src[position++];
        if (value === void 0)
          throw new Error("Unexpected end of buffer");
        return readBin(value);
      case 197:
        value = dataView.getUint16(position);
        position += 2;
        return readBin(value);
      case 198:
        value = dataView.getUint32(position);
        position += 4;
        return readBin(value);
      case 199:
        return readExt(src[position++]);
      case 200:
        value = dataView.getUint16(position);
        position += 2;
        return readExt(value);
      case 201:
        value = dataView.getUint32(position);
        position += 4;
        return readExt(value);
      case 202:
        value = dataView.getFloat32(position);
        if (currentUnpackr.useFloat32 > 2) {
          let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
          position += 4;
          return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
        }
        position += 4;
        return value;
      case 203:
        value = dataView.getFloat64(position);
        position += 8;
        return value;
      case 204:
        return src[position++];
      case 205:
        value = dataView.getUint16(position);
        position += 2;
        return value;
      case 206:
        value = dataView.getUint32(position);
        position += 4;
        return value;
      case 207:
        if (currentUnpackr.int64AsType === "number") {
          value = dataView.getUint32(position) * 4294967296;
          value += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value = dataView.getBigUint64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value = dataView.getBigUint64(position);
          if (value <= BigInt(2) << BigInt(52)) value = Number(value);
        } else
          value = dataView.getBigUint64(position);
        position += 8;
        return value;
      case 208:
        return dataView.getInt8(position++);
      case 209:
        value = dataView.getInt16(position);
        position += 2;
        return value;
      case 210:
        value = dataView.getInt32(position);
        position += 4;
        return value;
      case 211:
        if (currentUnpackr.int64AsType === "number") {
          value = dataView.getInt32(position) * 4294967296;
          value += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value = dataView.getBigInt64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value = dataView.getBigInt64(position);
          if (value >= BigInt(-2) << BigInt(52) && value <= BigInt(2) << BigInt(52)) value = Number(value);
        } else
          value = dataView.getBigInt64(position);
        position += 8;
        return value;
      case 212:
        value = src[position++];
        if (value == 114) {
          return recordDefinition(src[position++] & 63);
        } else {
          let extension = currentExtensions[value];
          if (extension) {
            if (extension.read) {
              position++;
              return extension.read(read());
            } else if (extension.noBuffer) {
              position++;
              return extension();
            } else
              return extension(src.subarray(position, ++position));
          } else
            throw new Error("Unknown extension " + value);
        }
      case 213:
        value = src[position];
        if (value == 114) {
          position++;
          return recordDefinition(src[position++] & 63, src[position++]);
        } else
          return readExt(2);
      case 214:
        return readExt(4);
      case 215:
        return readExt(8);
      case 216:
        return readExt(16);
      case 217:
        value = src[position++];
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value) - srcStringStart);
        }
        return readString8(value);
      case 218:
        value = dataView.getUint16(position);
        position += 2;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value) - srcStringStart);
        }
        return readString16(value);
      case 219:
        value = dataView.getUint32(position);
        position += 4;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value) - srcStringStart);
        }
        return readString32(value);
      case 220:
        value = dataView.getUint16(position);
        position += 2;
        return readArray(value);
      case 221:
        value = dataView.getUint32(position);
        position += 4;
        return readArray(value);
      case 222:
        value = dataView.getUint16(position);
        position += 2;
        return readMap(value);
      case 223:
        value = dataView.getUint32(position);
        position += 4;
        return readMap(value);
      default:
        if (token >= 224)
          return token - 256;
        if (token === void 0) {
          let error = new Error("Unexpected end of MessagePack data");
          error.incomplete = true;
          throw error;
        }
        throw new Error("Unknown MessagePack token " + token);
    }
  }
}
function createStructureReader(structure, firstId) {
  function readObject() {
    if (readObject.count++ > inlineObjectReadThreshold) {
      let readObject2 = structure.read = new Function("r", "return function(){return " + (currentUnpackr.freezeData ? "Object.freeze" : "") + "({" + structure.map((key) => key === "__proto__" ? "__proto_:r()" : validName.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read);
      if (structure.highByte === 0)
        structure.read = createSecondByteReader(firstId, structure.read);
      return readObject2();
    }
    let object = {};
    for (let i = 0, l = structure.length; i < l; i++) {
      let key = structure[i];
      if (key === "__proto__")
        key = "__proto_";
      object[key] = read();
    }
    if (currentUnpackr.freezeData)
      return Object.freeze(object);
    return object;
  }
  readObject.count = 0;
  if (structure.highByte === 0) {
    return createSecondByteReader(firstId, readObject);
  }
  return readObject;
}
function loadStructures() {
  let loadedStructures = saveState(() => {
    src = null;
    return currentUnpackr.getStructures();
  });
  return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);
}
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length))
      return result;
  }
  if (length > 64 && decoder)
    return decoder.decode(src.subarray(position, position += length));
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
function readArray(length) {
  let array = new Array(length);
  for (let i = 0; i < length; i++) {
    array[i] = read();
  }
  if (currentUnpackr.freezeData)
    return Object.freeze(array);
  return array;
}
function readMap(length) {
  if (currentUnpackr.mapsAsObjects) {
    let object = {};
    for (let i = 0; i < length; i++) {
      let key = readKey();
      if (key === "__proto__")
        key = "__proto_";
      object[key] = read();
    }
    return object;
  } else {
    let map = /* @__PURE__ */ new Map();
    for (let i = 0; i < length; i++) {
      map.set(read(), read());
    }
    return map;
  }
}
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0)
        return "";
      else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length < 3)
        return fromCharCode(a, b);
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readOnlyJSString() {
  let token = src[position++];
  let length;
  if (token < 192) {
    length = token - 160;
  } else {
    switch (token) {
      case 217:
        length = src[position++];
        break;
      case 218:
        length = dataView.getUint16(position);
        position += 2;
        break;
      case 219:
        length = dataView.getUint32(position);
        position += 4;
        break;
      default:
        throw new Error("Expected string");
    }
  }
  return readStringJS(length);
}
function readBin(length) {
  return currentUnpackr.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
function readExt(length) {
  let type = src[position++];
  if (currentExtensions[type]) {
    let end;
    return currentExtensions[type](src.subarray(position, end = position += length), (readPosition) => {
      position = readPosition;
      try {
        return read();
      } finally {
        position = end;
      }
    });
  } else
    throw new Error("Unknown extension type " + type);
}
function readKey() {
  let length = src[position++];
  if (length >= 160 && length < 192) {
    length = length - 160;
    if (srcStringEnd >= position)
      return srcString.slice(position - srcStringStart, (position += length) - srcStringStart);
    else if (!(srcStringEnd == 0 && srcEnd < 180))
      return readFixedString(length);
  } else {
    position--;
    return asSafeString(read());
  }
  let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 4095;
  let entry = keyCache[key];
  let checkPosition = position;
  let end = position + length - 3;
  let chunk;
  let i = 0;
  if (entry && entry.bytes == length) {
    while (checkPosition < end) {
      chunk = dataView.getUint32(checkPosition);
      if (chunk != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
      checkPosition += 4;
    }
    end += 3;
    while (checkPosition < end) {
      chunk = src[checkPosition++];
      if (chunk != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
    }
    if (checkPosition === end) {
      position = checkPosition;
      return entry.string;
    }
    end -= 3;
    checkPosition = position;
  }
  entry = [];
  keyCache[key] = entry;
  entry.bytes = length;
  while (checkPosition < end) {
    chunk = dataView.getUint32(checkPosition);
    entry.push(chunk);
    checkPosition += 4;
  }
  end += 3;
  while (checkPosition < end) {
    chunk = src[checkPosition++];
    entry.push(chunk);
  }
  let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);
  if (string != null)
    return entry.string = string;
  return entry.string = readFixedString(length);
}
function asSafeString(property) {
  if (typeof property === "string") return property;
  if (typeof property === "number" || typeof property === "boolean" || typeof property === "bigint") return property.toString();
  if (property == null) return property + "";
  if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every((item) => ["string", "number", "boolean", "bigint"].includes(typeof item))) {
    return property.flat().toString();
  }
  throw new Error(`Invalid property type for record: ${typeof property}`);
}
function saveState(callback) {
  if (onSaveState)
    onSaveState();
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedStructuresContents = currentStructures.slice(0, currentStructures.length);
  let savedPackr = currentUnpackr;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);
  currentUnpackr = savedPackr;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
function addExtension(extension) {
  if (extension.unpack)
    currentExtensions[extension.type] = extension.unpack;
  else
    currentExtensions[extension.type] = extension;
}
function roundFloat32(float32Number) {
  f32Array[0] = float32Number;
  let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
  return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
}
var decoder, src, srcEnd, position, EMPTY_ARRAY, strings, stringPosition, currentUnpackr, currentStructures, srcString, srcStringStart, srcStringEnd, bundledStrings, referenceMap, currentExtensions, dataView, defaultOptions, C1Type, C1, sequentialMode, inlineObjectReadThreshold, readStruct, onLoadedStructures, onSaveState, Unpackr, validName, createSecondByteReader, readFixedString, readString8, readString16, readString32, isNativeAccelerationEnabled, fromCharCode, keyCache, recordDefinition, errors, typedArrays, glbl, TEMP_BUNDLE, mult10, Decoder, defaultUnpackr, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, f32Array, u8Array;
var init_unpack = __esm({
  "../node_modules/@colyseus/msgpackr/unpack.js"() {
    try {
      decoder = new TextDecoder();
    } catch (error) {
    }
    position = 0;
    EMPTY_ARRAY = [];
    strings = EMPTY_ARRAY;
    stringPosition = 0;
    currentUnpackr = {};
    srcStringStart = 0;
    srcStringEnd = 0;
    currentExtensions = [];
    defaultOptions = {
      useRecords: false,
      mapsAsObjects: true
    };
    C1Type = class {
    };
    C1 = new C1Type();
    C1.name = "MessagePack 0xC1";
    sequentialMode = false;
    inlineObjectReadThreshold = 2;
    try {
      new Function("");
    } catch (error) {
      inlineObjectReadThreshold = Infinity;
    }
    Unpackr = class _Unpackr {
      constructor(options) {
        if (options) {
          if (options.useRecords === false && options.mapsAsObjects === void 0)
            options.mapsAsObjects = true;
          if (options.sequential && options.trusted !== false) {
            options.trusted = true;
            if (!options.structures && options.useRecords != false) {
              options.structures = [];
              if (!options.maxSharedStructures)
                options.maxSharedStructures = 0;
            }
          }
          if (options.structures)
            options.structures.sharedLength = options.structures.length;
          else if (options.getStructures) {
            (options.structures = []).uninitialized = true;
            options.structures.sharedLength = 0;
          }
          if (options.int64AsNumber) {
            options.int64AsType = "number";
          }
        }
        Object.assign(this, options);
      }
      unpack(source, options) {
        if (src) {
          return saveState(() => {
            clearSource();
            return this ? this.unpack(source, options) : _Unpackr.prototype.unpack.call(defaultOptions, source, options);
          });
        }
        if (!source.buffer && source.constructor === ArrayBuffer)
          source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
        if (typeof options === "object") {
          srcEnd = options.end || source.length;
          position = options.start || 0;
        } else {
          position = 0;
          srcEnd = options > -1 ? options : source.length;
        }
        stringPosition = 0;
        srcStringEnd = 0;
        srcString = null;
        strings = EMPTY_ARRAY;
        bundledStrings = null;
        src = source;
        try {
          dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
        } catch (error) {
          src = null;
          if (source instanceof Uint8Array)
            throw error;
          throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
        }
        if (this instanceof _Unpackr) {
          currentUnpackr = this;
          if (this.structures) {
            currentStructures = this.structures;
            return checkedRead(options);
          } else if (!currentStructures || currentStructures.length > 0) {
            currentStructures = [];
          }
        } else {
          currentUnpackr = defaultOptions;
          if (!currentStructures || currentStructures.length > 0)
            currentStructures = [];
        }
        return checkedRead(options);
      }
      unpackMultiple(source, forEach) {
        let values, lastPosition = 0;
        try {
          sequentialMode = true;
          let size = source.length;
          let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);
          if (forEach) {
            if (forEach(value, lastPosition, position) === false) return;
            while (position < size) {
              lastPosition = position;
              if (forEach(checkedRead(), lastPosition, position) === false) {
                return;
              }
            }
          } else {
            values = [value];
            while (position < size) {
              lastPosition = position;
              values.push(checkedRead());
            }
            return values;
          }
        } catch (error) {
          error.lastPosition = lastPosition;
          error.values = values;
          throw error;
        } finally {
          sequentialMode = false;
          clearSource();
        }
      }
      _mergeStructures(loadedStructures, existingStructures) {
        if (onLoadedStructures)
          loadedStructures = onLoadedStructures.call(this, loadedStructures);
        loadedStructures = loadedStructures || [];
        if (Object.isFrozen(loadedStructures))
          loadedStructures = loadedStructures.map((structure) => structure.slice(0));
        for (let i = 0, l = loadedStructures.length; i < l; i++) {
          let structure = loadedStructures[i];
          if (structure) {
            structure.isShared = true;
            if (i >= 32)
              structure.highByte = i - 32 >> 5;
          }
        }
        loadedStructures.sharedLength = loadedStructures.length;
        for (let id in existingStructures || []) {
          if (id >= 0) {
            let structure = loadedStructures[id];
            let existing = existingStructures[id];
            if (existing) {
              if (structure)
                (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;
              loadedStructures[id] = existing;
            }
          }
        }
        return this.structures = loadedStructures;
      }
      decode(source, options) {
        return this.unpack(source, options);
      }
    };
    validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
    createSecondByteReader = (firstId, read0) => {
      return function() {
        let highByte = src[position++];
        if (highByte === 0)
          return read0();
        let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
        let structure = currentStructures[id] || loadStructures()[id];
        if (!structure) {
          throw new Error("Record id is not defined for " + id);
        }
        if (!structure.read)
          structure.read = createStructureReader(structure, firstId);
        return structure.read();
      };
    };
    readFixedString = readStringJS;
    readString8 = readStringJS;
    readString16 = readStringJS;
    readString32 = readStringJS;
    isNativeAccelerationEnabled = false;
    fromCharCode = String.fromCharCode;
    keyCache = new Array(4096);
    recordDefinition = (id, highByte) => {
      let structure = read().map(asSafeString);
      let firstByte = id;
      if (highByte !== void 0) {
        id = id < 32 ? -((highByte << 5) + id) : (highByte << 5) + id;
        structure.highByte = highByte;
      }
      let existingStructure = currentStructures[id];
      if (existingStructure && (existingStructure.isShared || sequentialMode)) {
        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
      }
      currentStructures[id] = structure;
      structure.read = createStructureReader(structure, firstByte);
      return structure.read();
    };
    currentExtensions[0] = () => {
    };
    currentExtensions[0].noBuffer = true;
    currentExtensions[66] = (data) => {
      let length = data.length;
      let value = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
      for (let i = 1; i < length; i++) {
        value <<= BigInt(8);
        value += BigInt(data[i]);
      }
      return value;
    };
    errors = { Error, TypeError, ReferenceError };
    currentExtensions[101] = () => {
      let data = read();
      return (errors[data[0]] || Error)(data[1], { cause: data[2] });
    };
    currentExtensions[105] = (data) => {
      if (currentUnpackr.structuredClone === false) throw new Error("Structured clone extension is disabled");
      let id = dataView.getUint32(position - 4);
      if (!referenceMap)
        referenceMap = /* @__PURE__ */ new Map();
      let token = src[position];
      let target2;
      if (token >= 144 && token < 160 || token == 220 || token == 221)
        target2 = [];
      else
        target2 = {};
      let refEntry = { target: target2 };
      referenceMap.set(id, refEntry);
      let targetProperties = read();
      if (refEntry.used)
        return Object.assign(target2, targetProperties);
      refEntry.target = targetProperties;
      return targetProperties;
    };
    currentExtensions[112] = (data) => {
      if (currentUnpackr.structuredClone === false) throw new Error("Structured clone extension is disabled");
      let id = dataView.getUint32(position - 4);
      let refEntry = referenceMap.get(id);
      refEntry.used = true;
      return refEntry.target;
    };
    currentExtensions[115] = () => new Set(read());
    typedArrays = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type) => type + "Array");
    glbl = typeof globalThis === "object" ? globalThis : window;
    currentExtensions[116] = (data) => {
      let typeCode = data[0];
      let typedArrayName = typedArrays[typeCode];
      if (!typedArrayName) {
        if (typeCode === 16) {
          let ab = new ArrayBuffer(data.length - 1);
          let u8 = new Uint8Array(ab);
          u8.set(data.subarray(1));
          return ab;
        }
        throw new Error("Could not find typed array for code " + typeCode);
      }
      return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer);
    };
    currentExtensions[120] = () => {
      let data = read();
      return new RegExp(data[0], data[1]);
    };
    TEMP_BUNDLE = [];
    currentExtensions[98] = (data) => {
      let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
      let dataPosition = position;
      position += dataSize - data.length;
      bundledStrings = TEMP_BUNDLE;
      bundledStrings = [readOnlyJSString(), readOnlyJSString()];
      bundledStrings.position0 = 0;
      bundledStrings.position1 = 0;
      bundledStrings.postBundlePosition = position;
      position = dataPosition;
      return read();
    };
    currentExtensions[255] = (data) => {
      if (data.length == 4)
        return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1e3);
      else if (data.length == 8)
        return new Date(
          ((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1e3
        );
      else if (data.length == 12)
        return new Date(
          ((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1e3
        );
      else
        return /* @__PURE__ */ new Date("invalid");
    };
    mult10 = new Array(147);
    for (let i = 0; i < 256; i++) {
      mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
    }
    Decoder = Unpackr;
    defaultUnpackr = new Unpackr({ useRecords: false });
    unpack = defaultUnpackr.unpack;
    unpackMultiple = defaultUnpackr.unpackMultiple;
    decode = defaultUnpackr.unpack;
    FLOAT32_OPTIONS = {
      NEVER: 0,
      ALWAYS: 1,
      DECIMAL_ROUND: 3,
      DECIMAL_FIT: 4
    };
    f32Array = new Float32Array(1);
    u8Array = new Uint8Array(f32Array.buffer, 0, 4);
  }
});

// ../node_modules/@colyseus/msgpackr/pack.js
function writeExtBuffer(typedArray, type, allocateForWrite, encode2) {
  let length = typedArray.byteLength;
  if (length + 1 < 256) {
    var { target: target2, position: position3 } = allocateForWrite(4 + length);
    target2[position3++] = 199;
    target2[position3++] = length + 1;
  } else if (length + 1 < 65536) {
    var { target: target2, position: position3 } = allocateForWrite(5 + length);
    target2[position3++] = 200;
    target2[position3++] = length + 1 >> 8;
    target2[position3++] = length + 1 & 255;
  } else {
    var { target: target2, position: position3, targetView: targetView2 } = allocateForWrite(7 + length);
    target2[position3++] = 201;
    targetView2.setUint32(position3, length + 1);
    position3 += 4;
  }
  target2[position3++] = 116;
  target2[position3++] = type;
  if (!typedArray.buffer) typedArray = new Uint8Array(typedArray);
  target2.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position3);
}
function writeBuffer(buffer, allocateForWrite) {
  let length = buffer.byteLength;
  var target2, position3;
  if (length < 256) {
    var { target: target2, position: position3 } = allocateForWrite(length + 2);
    target2[position3++] = 196;
    target2[position3++] = length;
  } else if (length < 65536) {
    var { target: target2, position: position3 } = allocateForWrite(length + 3);
    target2[position3++] = 197;
    target2[position3++] = length >> 8;
    target2[position3++] = length & 255;
  } else {
    var { target: target2, position: position3, targetView: targetView2 } = allocateForWrite(length + 5);
    target2[position3++] = 198;
    targetView2.setUint32(position3, length);
    position3 += 4;
  }
  target2.set(buffer, position3);
}
function writeExtensionData(result, target2, position3, type) {
  let length = result.length;
  switch (length) {
    case 1:
      target2[position3++] = 212;
      break;
    case 2:
      target2[position3++] = 213;
      break;
    case 4:
      target2[position3++] = 214;
      break;
    case 8:
      target2[position3++] = 215;
      break;
    case 16:
      target2[position3++] = 216;
      break;
    default:
      if (length < 256) {
        target2[position3++] = 199;
        target2[position3++] = length;
      } else if (length < 65536) {
        target2[position3++] = 200;
        target2[position3++] = length >> 8;
        target2[position3++] = length & 255;
      } else {
        target2[position3++] = 201;
        target2[position3++] = length >> 24;
        target2[position3++] = length >> 16 & 255;
        target2[position3++] = length >> 8 & 255;
        target2[position3++] = length & 255;
      }
  }
  target2[position3++] = type;
  target2.set(result, position3);
  position3 += length;
  return position3;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 6;
  let lastEnd = serialized.length - distanceToMove;
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    let id = nextId.id;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 6;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 214;
    serialized[position3++] = 105;
    serialized[position3++] = id >> 24;
    serialized[position3++] = id >> 16 & 255;
    serialized[position3++] = id >> 8 & 255;
    serialized[position3++] = id & 255;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start, pack2, incrementPosition) {
  if (bundledStrings2.length > 0) {
    targetView.setUint32(bundledStrings2.position + start, position2 + incrementPosition - bundledStrings2.position - start);
    bundledStrings2.stringsPosition = position2 - start;
    let writeStrings = bundledStrings2;
    bundledStrings2 = null;
    pack2(writeStrings[0]);
    pack2(writeStrings[1]);
  }
}
function addExtension2(extension) {
  if (extension.Class) {
    if (!extension.pack && !extension.write)
      throw new Error("Extension has no pack or write function");
    if (extension.pack && !extension.type)
      throw new Error("Extension has no type (numeric code to identify the extension)");
    extensionClasses.unshift(extension.Class);
    extensions.unshift(extension);
  }
  addExtension(extension);
}
function prepareStructures(structures, packr) {
  structures.isCompatible = (existingStructures) => {
    let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
    if (!compatible)
      packr._mergeStructures(existingStructures);
    return compatible;
  };
  return structures;
}
var textEncoder, extensions, extensionClasses, hasNodeBuffer, ByteArrayAllocate, ByteArray, MAX_BUFFER_SIZE, target, keysTarget, targetView, position2, safeEnd, bundledStrings2, writeStructSlots, MAX_BUNDLE_SIZE, hasNonLatin, RECORD_SYMBOL, Packr, defaultPackr, pack, encode, Encoder, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE, RESET_BUFFER_MODE, RESERVE_START_SPACE;
var init_pack = __esm({
  "../node_modules/@colyseus/msgpackr/pack.js"() {
    init_unpack();
    init_unpack();
    init_unpack();
    try {
      textEncoder = new TextEncoder();
    } catch (error) {
    }
    hasNodeBuffer = typeof Buffer !== "undefined";
    ByteArrayAllocate = hasNodeBuffer ? function(length) {
      return Buffer.allocUnsafeSlow(length);
    } : Uint8Array;
    ByteArray = hasNodeBuffer ? Buffer : Uint8Array;
    MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
    position2 = 0;
    bundledStrings2 = null;
    MAX_BUNDLE_SIZE = 21760;
    hasNonLatin = /[\u0080-\uFFFF]/;
    RECORD_SYMBOL = Symbol("record-id");
    Packr = class extends Unpackr {
      constructor(options) {
        super(options);
        this.offset = 0;
        let typeBuffer;
        let start;
        let hasSharedUpdate;
        let structures;
        let referenceMap2;
        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position3) {
          return target.utf8Write(string, position3, target.byteLength - position3);
        } : textEncoder && textEncoder.encodeInto ? function(string, position3) {
          return textEncoder.encodeInto(string, target.subarray(position3)).written;
        } : false;
        let packr = this;
        if (!options)
          options = {};
        let isSequential = options && options.sequential;
        let hasSharedStructures = options.structures || options.saveStructures;
        let maxSharedStructures = options.maxSharedStructures;
        if (maxSharedStructures == null)
          maxSharedStructures = hasSharedStructures ? 32 : 0;
        if (maxSharedStructures > 8160)
          throw new Error("Maximum maxSharedStructure is 8160");
        if (options.structuredClone && options.moreTypes == void 0) {
          this.moreTypes = true;
        }
        let maxOwnStructures = options.maxOwnStructures;
        if (maxOwnStructures == null)
          maxOwnStructures = hasSharedStructures ? 32 : 64;
        if (!this.structures && options.useRecords != false)
          this.structures = [];
        let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
        let sharedLimitId = maxSharedStructures + 64;
        let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
        if (maxStructureId > 8256) {
          throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
        }
        let recordIdsToRemove = [];
        let transitionsCount = 0;
        let serializationsSinceTransitionRebuild = 0;
        this.pack = this.encode = function(value, encodeOptions) {
          if (!target) {
            target = new ByteArrayAllocate(8192);
            targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));
            position2 = 0;
          }
          safeEnd = target.length - 10;
          if (safeEnd - position2 < 2048) {
            target = new ByteArrayAllocate(target.length);
            targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));
            safeEnd = target.length - 10;
            position2 = 0;
          } else
            position2 = position2 + 7 & 2147483640;
          start = position2;
          if (encodeOptions & RESERVE_START_SPACE) position2 += encodeOptions & 255;
          referenceMap2 = packr.structuredClone ? /* @__PURE__ */ new Map() : null;
          if (packr.bundleStrings && typeof value !== "string") {
            bundledStrings2 = [];
            bundledStrings2.size = Infinity;
          } else
            bundledStrings2 = null;
          structures = packr.structures;
          if (structures) {
            if (structures.uninitialized)
              structures = packr._mergeStructures(packr.getStructures());
            let sharedLength = structures.sharedLength || 0;
            if (sharedLength > maxSharedStructures) {
              throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
            }
            if (!structures.transitions) {
              structures.transitions = /* @__PURE__ */ Object.create(null);
              for (let i = 0; i < sharedLength; i++) {
                let keys = structures[i];
                if (!keys)
                  continue;
                let nextTransition, transition = structures.transitions;
                for (let j = 0, l = keys.length; j < l; j++) {
                  let key = keys[j];
                  nextTransition = transition[key];
                  if (!nextTransition) {
                    nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  }
                  transition = nextTransition;
                }
                transition[RECORD_SYMBOL] = i + 64;
              }
              this.lastNamedStructuresLength = sharedLength;
            }
            if (!isSequential) {
              structures.nextId = sharedLength + 64;
            }
          }
          if (hasSharedUpdate)
            hasSharedUpdate = false;
          let encodingError;
          try {
            if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)
              writeStruct(value);
            else
              pack2(value);
            let lastBundle = bundledStrings2;
            if (bundledStrings2)
              writeBundles(start, pack2, 0);
            if (referenceMap2 && referenceMap2.idsToInsert) {
              let idsToInsert = referenceMap2.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
              let i = idsToInsert.length;
              let incrementPosition = -1;
              while (lastBundle && i > 0) {
                let insertionPoint = idsToInsert[--i].offset + start;
                if (insertionPoint < lastBundle.stringsPosition + start && incrementPosition === -1)
                  incrementPosition = 0;
                if (insertionPoint > lastBundle.position + start) {
                  if (incrementPosition >= 0)
                    incrementPosition += 6;
                } else {
                  if (incrementPosition >= 0) {
                    targetView.setUint32(
                      lastBundle.position + start,
                      targetView.getUint32(lastBundle.position + start) + incrementPosition
                    );
                    incrementPosition = -1;
                  }
                  lastBundle = lastBundle.previous;
                  i++;
                }
              }
              if (incrementPosition >= 0 && lastBundle) {
                targetView.setUint32(
                  lastBundle.position + start,
                  targetView.getUint32(lastBundle.position + start) + incrementPosition
                );
              }
              position2 += idsToInsert.length * 6;
              if (position2 > safeEnd)
                makeRoom(position2);
              packr.offset = position2;
              let serialized = insertIds(target.subarray(start, position2), idsToInsert);
              referenceMap2 = null;
              return serialized;
            }
            packr.offset = position2;
            if (encodeOptions & REUSE_BUFFER_MODE) {
              target.start = start;
              target.end = position2;
              return target;
            }
            return target.subarray(start, position2);
          } catch (error) {
            encodingError = error;
            throw error;
          } finally {
            if (structures) {
              resetStructures();
              if (hasSharedUpdate && packr.saveStructures) {
                let sharedLength = structures.sharedLength || 0;
                let returnBuffer = target.subarray(start, position2);
                let newSharedData = prepareStructures(structures, packr);
                if (!encodingError) {
                  if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                    return packr.pack(value, encodeOptions);
                  }
                  packr.lastNamedStructuresLength = sharedLength;
                  if (target.length > 1073741824) target = null;
                  return returnBuffer;
                }
              }
            }
            if (target.length > 1073741824) target = null;
            if (encodeOptions & RESET_BUFFER_MODE)
              position2 = start;
          }
        };
        const resetStructures = () => {
          if (serializationsSinceTransitionRebuild < 10)
            serializationsSinceTransitionRebuild++;
          let sharedLength = structures.sharedLength || 0;
          if (structures.length > sharedLength && !isSequential)
            structures.length = sharedLength;
          if (transitionsCount > 1e4) {
            structures.transitions = null;
            serializationsSinceTransitionRebuild = 0;
            transitionsCount = 0;
            if (recordIdsToRemove.length > 0)
              recordIdsToRemove = [];
          } else if (recordIdsToRemove.length > 0 && !isSequential) {
            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
              recordIdsToRemove[i][RECORD_SYMBOL] = 0;
            }
            recordIdsToRemove = [];
          }
        };
        const packArray = (value) => {
          var length = value.length;
          if (length < 16) {
            target[position2++] = 144 | length;
          } else if (length < 65536) {
            target[position2++] = 220;
            target[position2++] = length >> 8;
            target[position2++] = length & 255;
          } else {
            target[position2++] = 221;
            targetView.setUint32(position2, length);
            position2 += 4;
          }
          for (let i = 0; i < length; i++) {
            pack2(value[i]);
          }
        };
        const pack2 = (value) => {
          if (position2 > safeEnd)
            target = makeRoom(position2);
          var type = typeof value;
          var length;
          if (type === "string") {
            let strLength = value.length;
            if (bundledStrings2 && strLength >= 4 && strLength < 4096) {
              if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
                let extStart;
                let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
                if (position2 + maxBytes2 > safeEnd)
                  target = makeRoom(position2 + maxBytes2);
                let lastBundle;
                if (bundledStrings2.position) {
                  lastBundle = bundledStrings2;
                  target[position2] = 200;
                  position2 += 3;
                  target[position2++] = 98;
                  extStart = position2 - start;
                  position2 += 4;
                  writeBundles(start, pack2, 0);
                  targetView.setUint16(extStart + start - 3, position2 - start - extStart);
                } else {
                  target[position2++] = 214;
                  target[position2++] = 98;
                  extStart = position2 - start;
                  position2 += 4;
                }
                bundledStrings2 = ["", ""];
                bundledStrings2.previous = lastBundle;
                bundledStrings2.size = 0;
                bundledStrings2.position = extStart;
              }
              let twoByte = hasNonLatin.test(value);
              bundledStrings2[twoByte ? 0 : 1] += value;
              target[position2++] = 193;
              pack2(twoByte ? -strLength : strLength);
              return;
            }
            let headerSize;
            if (strLength < 32) {
              headerSize = 1;
            } else if (strLength < 256) {
              headerSize = 2;
            } else if (strLength < 65536) {
              headerSize = 3;
            } else {
              headerSize = 5;
            }
            let maxBytes = strLength * 3;
            if (position2 + maxBytes > safeEnd)
              target = makeRoom(position2 + maxBytes);
            if (strLength < 64 || !encodeUtf8) {
              let i, c1, c2, strPosition = position2 + headerSize;
              for (i = 0; i < strLength; i++) {
                c1 = value.charCodeAt(i);
                if (c1 < 128) {
                  target[strPosition++] = c1;
                } else if (c1 < 2048) {
                  target[strPosition++] = c1 >> 6 | 192;
                  target[strPosition++] = c1 & 63 | 128;
                } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                  c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                  i++;
                  target[strPosition++] = c1 >> 18 | 240;
                  target[strPosition++] = c1 >> 12 & 63 | 128;
                  target[strPosition++] = c1 >> 6 & 63 | 128;
                  target[strPosition++] = c1 & 63 | 128;
                } else {
                  target[strPosition++] = c1 >> 12 | 224;
                  target[strPosition++] = c1 >> 6 & 63 | 128;
                  target[strPosition++] = c1 & 63 | 128;
                }
              }
              length = strPosition - position2 - headerSize;
            } else {
              length = encodeUtf8(value, position2 + headerSize);
            }
            if (length < 32) {
              target[position2++] = 160 | length;
            } else if (length < 256) {
              if (headerSize < 2) {
                target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length);
              }
              target[position2++] = 217;
              target[position2++] = length;
            } else if (length < 65536) {
              if (headerSize < 3) {
                target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length);
              }
              target[position2++] = 218;
              target[position2++] = length >> 8;
              target[position2++] = length & 255;
            } else {
              if (headerSize < 5) {
                target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length);
              }
              target[position2++] = 219;
              targetView.setUint32(position2, length);
              position2 += 4;
            }
            position2 += length;
          } else if (type === "number") {
            if (value >>> 0 === value) {
              if (value < 32 || value < 128 && this.useRecords === false || value < 64 && !this.randomAccessStructure) {
                target[position2++] = value;
              } else if (value < 256) {
                target[position2++] = 204;
                target[position2++] = value;
              } else if (value < 65536) {
                target[position2++] = 205;
                target[position2++] = value >> 8;
                target[position2++] = value & 255;
              } else {
                target[position2++] = 206;
                targetView.setUint32(position2, value);
                position2 += 4;
              }
            } else if (value >> 0 === value) {
              if (value >= -32) {
                target[position2++] = 256 + value;
              } else if (value >= -128) {
                target[position2++] = 208;
                target[position2++] = value + 256;
              } else if (value >= -32768) {
                target[position2++] = 209;
                targetView.setInt16(position2, value);
                position2 += 2;
              } else {
                target[position2++] = 210;
                targetView.setInt32(position2, value);
                position2 += 4;
              }
            } else {
              let useFloat32;
              if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                target[position2++] = 202;
                targetView.setFloat32(position2, value);
                let xShifted;
                if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
                (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
                  position2 += 4;
                  return;
                } else
                  position2--;
              }
              target[position2++] = 203;
              targetView.setFloat64(position2, value);
              position2 += 8;
            }
          } else if (type === "object" || type === "function") {
            if (!value)
              target[position2++] = 192;
            else {
              if (referenceMap2) {
                let referee = referenceMap2.get(value);
                if (referee) {
                  if (!referee.id) {
                    let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                    referee.id = idsToInsert.push(referee);
                  }
                  target[position2++] = 214;
                  target[position2++] = 112;
                  targetView.setUint32(position2, referee.id);
                  position2 += 4;
                  return;
                } else
                  referenceMap2.set(value, { offset: position2 - start });
              }
              let constructor = value.constructor;
              if (constructor === Object) {
                writeObject(value);
              } else if (constructor === Array) {
                packArray(value);
              } else if (constructor === Map) {
                if (this.mapAsEmptyObject) target[position2++] = 128;
                else {
                  length = value.size;
                  if (length < 16) {
                    target[position2++] = 128 | length;
                  } else if (length < 65536) {
                    target[position2++] = 222;
                    target[position2++] = length >> 8;
                    target[position2++] = length & 255;
                  } else {
                    target[position2++] = 223;
                    targetView.setUint32(position2, length);
                    position2 += 4;
                  }
                  for (let [key, entryValue] of value) {
                    pack2(key);
                    pack2(entryValue);
                  }
                }
              } else {
                for (let i = 0, l = extensions.length; i < l; i++) {
                  let extensionClass = extensionClasses[i];
                  if (value instanceof extensionClass) {
                    let extension = extensions[i];
                    if (extension.write) {
                      if (extension.type) {
                        target[position2++] = 212;
                        target[position2++] = extension.type;
                        target[position2++] = 0;
                      }
                      let writeResult = extension.write.call(this, value);
                      if (writeResult === value) {
                        if (Array.isArray(value)) {
                          packArray(value);
                        } else {
                          writeObject(value);
                        }
                      } else {
                        pack2(writeResult);
                      }
                      return;
                    }
                    let currentTarget = target;
                    let currentTargetView = targetView;
                    let currentPosition = position2;
                    target = null;
                    let result;
                    try {
                      result = extension.pack.call(this, value, (size) => {
                        target = currentTarget;
                        currentTarget = null;
                        position2 += size;
                        if (position2 > safeEnd)
                          makeRoom(position2);
                        return {
                          target,
                          targetView,
                          position: position2 - size
                        };
                      }, pack2);
                    } finally {
                      if (currentTarget) {
                        target = currentTarget;
                        targetView = currentTargetView;
                        position2 = currentPosition;
                        safeEnd = target.length - 10;
                      }
                    }
                    if (result) {
                      if (result.length + position2 > safeEnd)
                        makeRoom(result.length + position2);
                      position2 = writeExtensionData(result, target, position2, extension.type);
                    }
                    return;
                  }
                }
                if (Array.isArray(value)) {
                  packArray(value);
                } else {
                  if (value.toJSON) {
                    const json = value.toJSON();
                    if (json !== value)
                      return pack2(json);
                  }
                  if (type === "function")
                    return pack2(this.writeFunction && this.writeFunction(value));
                  writeObject(value);
                }
              }
            }
          } else if (type === "boolean") {
            target[position2++] = value ? 195 : 194;
          } else if (type === "bigint") {
            if (value < BigInt(1) << BigInt(63) && value >= -(BigInt(1) << BigInt(63))) {
              target[position2++] = 211;
              targetView.setBigInt64(position2, value);
            } else if (value < BigInt(1) << BigInt(64) && value > 0) {
              target[position2++] = 207;
              targetView.setBigUint64(position2, value);
            } else {
              if (this.largeBigIntToFloat) {
                target[position2++] = 203;
                targetView.setFloat64(position2, Number(value));
              } else if (this.largeBigIntToString) {
                return pack2(value.toString());
              } else if (this.useBigIntExtension && value < BigInt(2) ** BigInt(1023) && value > -(BigInt(2) ** BigInt(1023))) {
                target[position2++] = 199;
                position2++;
                target[position2++] = 66;
                let bytes = [];
                let alignedSign;
                do {
                  let byte = value & BigInt(255);
                  alignedSign = (byte & BigInt(128)) === (value < BigInt(0) ? BigInt(128) : BigInt(0));
                  bytes.push(byte);
                  value >>= BigInt(8);
                } while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));
                target[position2 - 2] = bytes.length;
                for (let i = bytes.length; i > 0; ) {
                  target[position2++] = Number(bytes[--i]);
                }
                return;
              } else {
                throw new RangeError(value + " was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string");
              }
            }
            position2 += 8;
          } else if (type === "undefined") {
            if (this.encodeUndefinedAsNil)
              target[position2++] = 192;
            else {
              target[position2++] = 212;
              target[position2++] = 0;
              target[position2++] = 0;
            }
          } else {
            throw new Error("Unknown type: " + type);
          }
        };
        const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object) => {
          let keys;
          if (this.skipValues) {
            keys = [];
            for (let key2 in object) {
              if ((typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key2)) && !this.skipValues.includes(object[key2]))
                keys.push(key2);
            }
          } else {
            keys = Object.keys(object);
          }
          let length = keys.length;
          if (length < 16) {
            target[position2++] = 128 | length;
          } else if (length < 65536) {
            target[position2++] = 222;
            target[position2++] = length >> 8;
            target[position2++] = length & 255;
          } else {
            target[position2++] = 223;
            targetView.setUint32(position2, length);
            position2 += 4;
          }
          let key;
          if (this.coercibleKeyAsNumber) {
            for (let i = 0; i < length; i++) {
              key = keys[i];
              let num = Number(key);
              pack2(isNaN(num) ? key : num);
              pack2(object[key]);
            }
          } else {
            for (let i = 0; i < length; i++) {
              pack2(key = keys[i]);
              pack2(object[key]);
            }
          }
        } : (object) => {
          target[position2++] = 222;
          let objectOffset = position2 - start;
          position2 += 2;
          let size = 0;
          for (let key in object) {
            if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
              pack2(key);
              pack2(object[key]);
              size++;
            }
          }
          if (size > 65535) {
            throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');
          }
          target[objectOffset++ + start] = size >> 8;
          target[objectOffset + start] = size & 255;
        };
        const writeRecord = this.useRecords === false ? writePlainObject : options.progressiveRecords && !useTwoByteRecords ? (
          // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
          (object) => {
            let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
            let objectOffset = position2++ - start;
            let wroteKeys;
            for (let key in object) {
              if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
                nextTransition = transition[key];
                if (nextTransition)
                  transition = nextTransition;
                else {
                  let keys = Object.keys(object);
                  let lastTransition = transition;
                  transition = structures.transitions;
                  let newTransitions = 0;
                  for (let i = 0, l = keys.length; i < l; i++) {
                    let key2 = keys[i];
                    nextTransition = transition[key2];
                    if (!nextTransition) {
                      nextTransition = transition[key2] = /* @__PURE__ */ Object.create(null);
                      newTransitions++;
                    }
                    transition = nextTransition;
                  }
                  if (objectOffset + start + 1 == position2) {
                    position2--;
                    newRecord(transition, keys, newTransitions);
                  } else
                    insertNewRecord(transition, keys, objectOffset, newTransitions);
                  wroteKeys = true;
                  transition = lastTransition[key];
                }
                pack2(object[key]);
              }
            }
            if (!wroteKeys) {
              let recordId = transition[RECORD_SYMBOL];
              if (recordId)
                target[objectOffset + start] = recordId;
              else
                insertNewRecord(transition, Object.keys(object), objectOffset, 0);
            }
          }
        ) : (object) => {
          let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
          let newTransitions = 0;
          for (let key in object) if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
          }
          let recordId = transition[RECORD_SYMBOL];
          if (recordId) {
            if (recordId >= 96 && useTwoByteRecords) {
              target[position2++] = ((recordId -= 96) & 31) + 96;
              target[position2++] = recordId >> 5;
            } else
              target[position2++] = recordId;
          } else {
            newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);
          }
          for (let key in object)
            if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
              pack2(object[key]);
            }
        };
        const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
        const writeObject = checkUseRecords ? (object) => {
          checkUseRecords(object) ? writeRecord(object) : writePlainObject(object);
        } : writeRecord;
        const makeRoom = (end) => {
          let newSize;
          if (end > 16777216) {
            if (end - start > MAX_BUFFER_SIZE)
              throw new Error("Packed buffer would be larger than maximum buffer size");
            newSize = Math.min(
              MAX_BUFFER_SIZE,
              Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
            );
          } else
            newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
          let newBuffer = new ByteArrayAllocate(newSize);
          targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
          end = Math.min(end, target.length);
          if (target.copy)
            target.copy(newBuffer, 0, start, end);
          else
            newBuffer.set(target.slice(start, end));
          position2 -= start;
          start = 0;
          safeEnd = newBuffer.length - 10;
          return target = newBuffer;
        };
        const newRecord = (transition, keys, newTransitions) => {
          let recordId = structures.nextId;
          if (!recordId)
            recordId = 64;
          if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {
            recordId = structures.nextOwnId;
            if (!(recordId < maxStructureId))
              recordId = sharedLimitId;
            structures.nextOwnId = recordId + 1;
          } else {
            if (recordId >= maxStructureId)
              recordId = sharedLimitId;
            structures.nextId = recordId + 1;
          }
          let highByte = keys.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
          transition[RECORD_SYMBOL] = recordId;
          transition.__keys__ = keys;
          structures[recordId - 64] = keys;
          if (recordId < sharedLimitId) {
            keys.isShared = true;
            structures.sharedLength = recordId - 63;
            hasSharedUpdate = true;
            if (highByte >= 0) {
              target[position2++] = (recordId & 31) + 96;
              target[position2++] = highByte;
            } else {
              target[position2++] = recordId;
            }
          } else {
            if (highByte >= 0) {
              target[position2++] = 213;
              target[position2++] = 114;
              target[position2++] = (recordId & 31) + 96;
              target[position2++] = highByte;
            } else {
              target[position2++] = 212;
              target[position2++] = 114;
              target[position2++] = recordId;
            }
            if (newTransitions)
              transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
            if (recordIdsToRemove.length >= maxOwnStructures)
              recordIdsToRemove.shift()[RECORD_SYMBOL] = 0;
            recordIdsToRemove.push(transition);
            pack2(keys);
          }
        };
        const insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {
          let mainTarget = target;
          let mainPosition = position2;
          let mainSafeEnd = safeEnd;
          let mainStart = start;
          target = keysTarget;
          position2 = 0;
          start = 0;
          if (!target)
            keysTarget = target = new ByteArrayAllocate(8192);
          safeEnd = target.length - 10;
          newRecord(transition, keys, newTransitions);
          keysTarget = target;
          let keysPosition = position2;
          target = mainTarget;
          position2 = mainPosition;
          safeEnd = mainSafeEnd;
          start = mainStart;
          if (keysPosition > 1) {
            let newEnd = position2 + keysPosition - 1;
            if (newEnd > safeEnd)
              makeRoom(newEnd);
            let insertionPosition = insertionOffset + start;
            target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position2);
            target.set(keysTarget.slice(0, keysPosition), insertionPosition);
            position2 = newEnd;
          } else {
            target[insertionOffset + start] = keysTarget[0];
          }
        };
        const writeStruct = (object) => {
          let newPosition = writeStructSlots(object, target, start, position2, structures, makeRoom, (value, newPosition2, notifySharedUpdate) => {
            if (notifySharedUpdate)
              return hasSharedUpdate = true;
            position2 = newPosition2;
            let startTarget = target;
            pack2(value);
            resetStructures();
            if (startTarget !== target) {
              return { position: position2, targetView, target };
            }
            return position2;
          }, this);
          if (newPosition === 0)
            return writeObject(object);
          position2 = newPosition;
        };
      }
      useBuffer(buffer) {
        target = buffer;
        target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));
        position2 = 0;
      }
      set position(value) {
        position2 = value;
      }
      get position() {
        return position2;
      }
      set buffer(buffer) {
        target = buffer;
      }
      get buffer() {
        return target;
      }
      clearSharedData() {
        if (this.structures)
          this.structures = [];
        if (this.typedStructs)
          this.typedStructs = [];
      }
    };
    extensionClasses = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, C1Type];
    extensions = [{
      pack(date, allocateForWrite, pack2) {
        let seconds = date.getTime() / 1e3;
        if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
          let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(6);
          target2[position3++] = 214;
          target2[position3++] = 255;
          targetView2.setUint32(position3, seconds);
        } else if (seconds > 0 && seconds < 4294967296) {
          let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(10);
          target2[position3++] = 215;
          target2[position3++] = 255;
          targetView2.setUint32(position3, date.getMilliseconds() * 4e6 + (seconds / 1e3 / 4294967296 >> 0));
          targetView2.setUint32(position3 + 4, seconds);
        } else if (isNaN(seconds)) {
          if (this.onInvalidDate) {
            allocateForWrite(0);
            return pack2(this.onInvalidDate());
          }
          let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(3);
          target2[position3++] = 212;
          target2[position3++] = 255;
          target2[position3++] = 255;
        } else {
          let { target: target2, targetView: targetView2, position: position3 } = allocateForWrite(15);
          target2[position3++] = 199;
          target2[position3++] = 12;
          target2[position3++] = 255;
          targetView2.setUint32(position3, date.getMilliseconds() * 1e6);
          targetView2.setBigInt64(position3 + 4, BigInt(Math.floor(seconds)));
        }
      }
    }, {
      pack(set, allocateForWrite, pack2) {
        if (this.setAsEmptyObject) {
          allocateForWrite(0);
          return pack2({});
        }
        let array = Array.from(set);
        let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
        if (this.moreTypes) {
          target2[position3++] = 212;
          target2[position3++] = 115;
          target2[position3++] = 0;
        }
        pack2(array);
      }
    }, {
      pack(error, allocateForWrite, pack2) {
        let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
        if (this.moreTypes) {
          target2[position3++] = 212;
          target2[position3++] = 101;
          target2[position3++] = 0;
        }
        pack2([error.name, error.message, error.cause]);
      }
    }, {
      pack(regex, allocateForWrite, pack2) {
        let { target: target2, position: position3 } = allocateForWrite(this.moreTypes ? 3 : 0);
        if (this.moreTypes) {
          target2[position3++] = 212;
          target2[position3++] = 120;
          target2[position3++] = 0;
        }
        pack2([regex.source, regex.flags]);
      }
    }, {
      pack(arrayBuffer, allocateForWrite) {
        if (this.moreTypes)
          writeExtBuffer(arrayBuffer, 16, allocateForWrite);
        else
          writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
      }
    }, {
      pack(typedArray, allocateForWrite) {
        let constructor = typedArray.constructor;
        if (constructor !== ByteArray && this.moreTypes)
          writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);
        else
          writeBuffer(typedArray, allocateForWrite);
      }
    }, {
      pack(c1, allocateForWrite) {
        let { target: target2, position: position3 } = allocateForWrite(1);
        target2[position3] = 193;
      }
    }];
    defaultPackr = new Packr({ useRecords: false });
    pack = defaultPackr.pack;
    encode = defaultPackr.pack;
    Encoder = Packr;
    ({ NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS);
    REUSE_BUFFER_MODE = 512;
    RESET_BUFFER_MODE = 1024;
    RESERVE_START_SPACE = 2048;
  }
});

// ../node_modules/@colyseus/msgpackr/iterators.js
function packIter(objectIterator, options = {}) {
  if (!objectIterator || typeof objectIterator !== "object") {
    throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
  } else if (typeof objectIterator[Symbol.iterator] === "function") {
    return packIterSync(objectIterator, options);
  } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
    return packIterAsync(objectIterator, options);
  } else {
    throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
  }
}
function* packIterSync(objectIterator, options) {
  const packr = new Packr(options);
  for (const value of objectIterator) {
    yield packr.pack(value);
  }
}
async function* packIterAsync(objectIterator, options) {
  const packr = new Packr(options);
  for await (const value of objectIterator) {
    yield packr.pack(value);
  }
}
function unpackIter(bufferIterator, options = {}) {
  if (!bufferIterator || typeof bufferIterator !== "object") {
    throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
  }
  const unpackr = new Unpackr(options);
  let incomplete;
  const parser = (chunk) => {
    let yields;
    if (incomplete) {
      chunk = Buffer.concat([incomplete, chunk]);
      incomplete = void 0;
    }
    try {
      yields = unpackr.unpackMultiple(chunk);
    } catch (err) {
      if (err.incomplete) {
        incomplete = chunk.slice(err.lastPosition);
        yields = err.values;
      } else {
        throw err;
      }
    }
    return yields;
  };
  if (typeof bufferIterator[Symbol.iterator] === "function") {
    return function* iter() {
      for (const value of bufferIterator) {
        yield* parser(value);
      }
    }();
  } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
    return async function* iter() {
      for await (const value of bufferIterator) {
        yield* parser(value);
      }
    }();
  }
}
var decodeIter, encodeIter;
var init_iterators = __esm({
  "../node_modules/@colyseus/msgpackr/iterators.js"() {
    init_pack();
    init_unpack();
    decodeIter = unpackIter;
    encodeIter = packIter;
  }
});

// ../node_modules/@colyseus/msgpackr/index.js
var msgpackr_exports = {};
__export(msgpackr_exports, {
  ALWAYS: () => ALWAYS,
  C1: () => C1,
  DECIMAL_FIT: () => DECIMAL_FIT,
  DECIMAL_ROUND: () => DECIMAL_ROUND,
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  FLOAT32_OPTIONS: () => FLOAT32_OPTIONS,
  NEVER: () => NEVER,
  Packr: () => Packr,
  RESERVE_START_SPACE: () => RESERVE_START_SPACE,
  RESET_BUFFER_MODE: () => RESET_BUFFER_MODE,
  REUSE_BUFFER_MODE: () => REUSE_BUFFER_MODE,
  Unpackr: () => Unpackr,
  addExtension: () => addExtension2,
  clearSource: () => clearSource,
  decode: () => decode,
  decodeIter: () => decodeIter,
  encode: () => encode,
  encodeIter: () => encodeIter,
  isNativeAccelerationEnabled: () => isNativeAccelerationEnabled,
  mapsAsObjects: () => mapsAsObjects,
  pack: () => pack,
  roundFloat32: () => roundFloat32,
  unpack: () => unpack,
  unpackMultiple: () => unpackMultiple,
  useRecords: () => useRecords
});
var useRecords, mapsAsObjects;
var init_msgpackr = __esm({
  "../node_modules/@colyseus/msgpackr/index.js"() {
    init_pack();
    init_unpack();
    init_iterators();
    useRecords = false;
    mapsAsObjects = true;
  }
});

// ../node_modules/colyseus.js/build/cjs/Room.js
var require_Room = __commonJS({
  "../node_modules/colyseus.js/build/cjs/Room.js"(exports) {
    "use strict";
    var Connection = require_Connection();
    var Protocol = require_Protocol();
    var Serializer = require_Serializer();
    var nanoevents = require_nanoevents();
    var signal = require_signal();
    var schema = require_umd();
    var SchemaSerializer = require_SchemaSerializer();
    var Errors = require_Errors();
    var msgpackr = (init_msgpackr(), __toCommonJS(msgpackr_exports));
    var Room = class _Room {
      constructor(name, rootSchema) {
        this.onStateChange = signal.createSignal();
        this.onError = signal.createSignal();
        this.onLeave = signal.createSignal();
        this.onJoin = signal.createSignal();
        this.hasJoined = false;
        this.onMessageHandlers = nanoevents.createNanoEvents();
        this.roomId = null;
        this.name = name;
        this.packr = new msgpackr.Packr();
        this.packr.encode(void 0);
        if (rootSchema) {
          this.serializer = new (Serializer.getSerializer("schema"))();
          this.rootSchema = rootSchema;
          this.serializer.state = new rootSchema();
        }
        this.onError((code, message) => {
          var _a;
          return (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `colyseus.js - onError => (${code}) ${message}`);
        });
        this.onLeave(() => this.removeAllListeners());
      }
      connect(endpoint, devModeCloseCallback, room = this, options, headers) {
        const connection = new Connection.Connection(options.protocol);
        room.connection = connection;
        connection.events.onmessage = _Room.prototype.onMessageCallback.bind(room);
        connection.events.onclose = function(e) {
          var _a;
          if (!room.hasJoined) {
            (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room connection was closed unexpectedly (${e.code}): ${e.reason}`);
            room.onError.invoke(e.code, e.reason);
            return;
          }
          if (e.code === Errors.CloseCode.DEVMODE_RESTART && devModeCloseCallback) {
            devModeCloseCallback();
          } else {
            room.onLeave.invoke(e.code, e.reason);
            room.destroy();
          }
        };
        connection.events.onerror = function(e) {
          var _a;
          (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `Room, onError (${e.code}): ${e.reason}`);
          room.onError.invoke(e.code, e.reason);
        };
        if (options.protocol === "h3") {
          const url = new URL(endpoint);
          connection.connect(url.origin, options);
        } else {
          connection.connect(endpoint, headers);
        }
      }
      leave(consented = true) {
        return new Promise((resolve) => {
          this.onLeave((code) => resolve(code));
          if (this.connection) {
            if (consented) {
              this.packr.buffer[0] = Protocol.Protocol.LEAVE_ROOM;
              this.connection.send(this.packr.buffer.subarray(0, 1));
            } else {
              this.connection.close();
            }
          } else {
            this.onLeave.invoke(Errors.CloseCode.CONSENTED);
          }
        });
      }
      onMessage(type, callback) {
        return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);
      }
      send(type, message) {
        const it = { offset: 1 };
        this.packr.buffer[0] = Protocol.Protocol.ROOM_DATA;
        if (typeof type === "string") {
          schema.encode.string(this.packr.buffer, type, it);
        } else {
          schema.encode.number(this.packr.buffer, type, it);
        }
        this.packr.position = 0;
        const data = message !== void 0 ? this.packr.pack(message, 2048 + it.offset) : this.packr.buffer.subarray(0, it.offset);
        this.connection.send(data);
      }
      sendUnreliable(type, message) {
        const it = { offset: 1 };
        this.packr.buffer[0] = Protocol.Protocol.ROOM_DATA;
        if (typeof type === "string") {
          schema.encode.string(this.packr.buffer, type, it);
        } else {
          schema.encode.number(this.packr.buffer, type, it);
        }
        this.packr.position = 0;
        const data = message !== void 0 ? this.packr.pack(message, 2048 + it.offset) : this.packr.buffer.subarray(0, it.offset);
        this.connection.sendUnreliable(data);
      }
      sendBytes(type, bytes) {
        const it = { offset: 1 };
        this.packr.buffer[0] = Protocol.Protocol.ROOM_DATA_BYTES;
        if (typeof type === "string") {
          schema.encode.string(this.packr.buffer, type, it);
        } else {
          schema.encode.number(this.packr.buffer, type, it);
        }
        if (bytes.byteLength + it.offset > this.packr.buffer.byteLength) {
          const newBuffer = new Uint8Array(it.offset + bytes.byteLength);
          newBuffer.set(this.packr.buffer);
          this.packr.useBuffer(newBuffer);
        }
        this.packr.buffer.set(bytes, it.offset);
        this.connection.send(this.packr.buffer.subarray(0, it.offset + bytes.byteLength));
      }
      get state() {
        return this.serializer.getState();
      }
      removeAllListeners() {
        this.onJoin.clear();
        this.onStateChange.clear();
        this.onError.clear();
        this.onLeave.clear();
        this.onMessageHandlers.events = {};
        if (this.serializer instanceof SchemaSerializer.SchemaSerializer) {
          this.serializer.decoder.root.callbacks = {};
        }
      }
      onMessageCallback(event) {
        const buffer = new Uint8Array(event.data);
        const it = { offset: 1 };
        const code = buffer[0];
        if (code === Protocol.Protocol.JOIN_ROOM) {
          const reconnectionToken = schema.decode.utf8Read(buffer, it, buffer[it.offset++]);
          this.serializerId = schema.decode.utf8Read(buffer, it, buffer[it.offset++]);
          if (!this.serializer) {
            const serializer = Serializer.getSerializer(this.serializerId);
            this.serializer = new serializer();
          }
          if (buffer.byteLength > it.offset && this.serializer.handshake) {
            this.serializer.handshake(buffer, it);
          }
          this.reconnectionToken = `${this.roomId}:${reconnectionToken}`;
          this.hasJoined = true;
          this.onJoin.invoke();
          this.packr.buffer[0] = Protocol.Protocol.JOIN_ROOM;
          this.connection.send(this.packr.buffer.subarray(0, 1));
        } else if (code === Protocol.Protocol.ERROR) {
          const code2 = schema.decode.number(buffer, it);
          const message = schema.decode.string(buffer, it);
          this.onError.invoke(code2, message);
        } else if (code === Protocol.Protocol.LEAVE_ROOM) {
          this.leave();
        } else if (code === Protocol.Protocol.ROOM_STATE) {
          this.serializer.setState(buffer, it);
          this.onStateChange.invoke(this.serializer.getState());
        } else if (code === Protocol.Protocol.ROOM_STATE_PATCH) {
          this.serializer.patch(buffer, it);
          this.onStateChange.invoke(this.serializer.getState());
        } else if (code === Protocol.Protocol.ROOM_DATA) {
          const type = schema.decode.stringCheck(buffer, it) ? schema.decode.string(buffer, it) : schema.decode.number(buffer, it);
          const message = buffer.byteLength > it.offset ? msgpackr.unpack(buffer, { start: it.offset }) : void 0;
          this.dispatchMessage(type, message);
        } else if (code === Protocol.Protocol.ROOM_DATA_BYTES) {
          const type = schema.decode.stringCheck(buffer, it) ? schema.decode.string(buffer, it) : schema.decode.number(buffer, it);
          this.dispatchMessage(type, buffer.subarray(it.offset));
        }
      }
      dispatchMessage(type, message) {
        var _a;
        const messageType = this.getMessageHandlerKey(type);
        if (this.onMessageHandlers.events[messageType]) {
          this.onMessageHandlers.emit(messageType, message);
        } else if (this.onMessageHandlers.events["*"]) {
          this.onMessageHandlers.emit("*", type, message);
        } else {
          (_a = console.warn) === null || _a === void 0 ? void 0 : _a.call(console, `colyseus.js: onMessage() not registered for type '${type}'.`);
        }
      }
      destroy() {
        if (this.serializer) {
          this.serializer.teardown();
        }
      }
      getMessageHandlerKey(type) {
        switch (typeof type) {
          case "string":
            return type;
          case "number":
            return `i${type}`;
          default:
            throw new Error("invalid message type.");
        }
      }
    };
    exports.Room = Room;
  }
});

// ../node_modules/@colyseus/httpie/xhr/index.mjs
var xhr_exports = {};
__export(xhr_exports, {
  del: () => del,
  get: () => get,
  patch: () => patch,
  post: () => post,
  put: () => put,
  send: () => send
});
function apply(src2, tar) {
  tar.headers = src2.headers || {};
  tar.statusMessage = src2.statusText;
  tar.statusCode = src2.status;
  tar.data = src2.response;
}
function send(method, uri, opts) {
  return new Promise(function(res, rej) {
    opts = opts || {};
    var req = new XMLHttpRequest();
    var k, tmp, arr, str = opts.body;
    var headers = opts.headers || {};
    if (opts.timeout) req.timeout = opts.timeout;
    req.ontimeout = req.onerror = function(err) {
      err.timeout = err.type == "timeout";
      rej(err);
    };
    req.onabort = function(err) {
      err.aborted = true;
      rej(err);
    };
    req.open(method, uri.href || uri);
    req.onload = function() {
      arr = req.getAllResponseHeaders().trim().split(/[\r\n]+/);
      apply(req, req);
      while (tmp = arr.shift()) {
        tmp = tmp.split(": ");
        req.headers[tmp.shift().toLowerCase()] = tmp.join(": ");
      }
      tmp = req.headers["content-type"];
      if (tmp && !!~tmp.indexOf("application/json")) {
        try {
          req.data = JSON.parse(req.data, opts.reviver);
        } catch (err) {
          apply(req, err);
          return rej(err);
        }
      }
      (req.status >= 400 ? rej : res)(req);
    };
    if (typeof FormData < "u" && str instanceof FormData) {
    } else if (str && typeof str == "object") {
      headers["content-type"] = "application/json";
      str = JSON.stringify(str);
    }
    req.withCredentials = !!opts.withCredentials;
    for (k in headers) {
      req.setRequestHeader(k, headers[k]);
    }
    req.send(str);
    if (opts.signal) {
      opts.signal.addEventListener("abort", function() {
        req.abort();
      });
    }
  });
}
var get, post, patch, del, put;
var init_xhr = __esm({
  "../node_modules/@colyseus/httpie/xhr/index.mjs"() {
    get = send.bind(send, "GET");
    post = send.bind(send, "POST");
    patch = send.bind(send, "PATCH");
    del = send.bind(send, "DELETE");
    put = send.bind(send, "PUT");
  }
});

// ../node_modules/colyseus.js/build/cjs/HTTP.js
var require_HTTP = __commonJS({
  "../node_modules/colyseus.js/build/cjs/HTTP.js"(exports) {
    "use strict";
    var Errors = require_Errors();
    var httpie = (init_xhr(), __toCommonJS(xhr_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var httpie__namespace = _interopNamespaceDefault(httpie);
    var HTTP = class {
      constructor(client, headers = {}) {
        this.client = client;
        this.headers = headers;
      }
      get(path, options = {}) {
        return this.request("get", path, options);
      }
      post(path, options = {}) {
        return this.request("post", path, options);
      }
      del(path, options = {}) {
        return this.request("del", path, options);
      }
      put(path, options = {}) {
        return this.request("put", path, options);
      }
      request(method, path, options = {}) {
        return httpie__namespace[method](this.client["getHttpEndpoint"](path), this.getOptions(options)).catch((e) => {
          var _a;
          if (e.aborted) {
            throw new Errors.AbortError("Request aborted");
          }
          const status = e.statusCode;
          const message = ((_a = e.data) === null || _a === void 0 ? void 0 : _a.error) || e.statusMessage || e.message;
          if (!status && !message) {
            throw e;
          }
          throw new Errors.ServerError(status, message);
        });
      }
      getOptions(options) {
        options.headers = Object.assign({}, this.headers, options.headers);
        if (this.authToken) {
          options.headers["Authorization"] = `Bearer ${this.authToken}`;
        }
        if (typeof cc !== "undefined" && cc.sys && cc.sys.isNative) ;
        else {
          options.withCredentials = true;
        }
        return options;
      }
    };
    exports.HTTP = HTTP;
  }
});

// ../node_modules/colyseus.js/build/cjs/Storage.js
var require_Storage = __commonJS({
  "../node_modules/colyseus.js/build/cjs/Storage.js"(exports) {
    "use strict";
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var storage;
    function getStorage() {
      if (!storage) {
        try {
          storage = typeof cc !== "undefined" && cc.sys && cc.sys.localStorage ? cc.sys.localStorage : window.localStorage;
        } catch (e) {
        }
      }
      if (!storage && typeof globalThis.indexedDB !== "undefined") {
        storage = new IndexedDBStorage();
      }
      if (!storage) {
        storage = {
          cache: {},
          setItem: function(key, value) {
            this.cache[key] = value;
          },
          getItem: function(key) {
            this.cache[key];
          },
          removeItem: function(key) {
            delete this.cache[key];
          }
        };
      }
      return storage;
    }
    function setItem(key, value) {
      getStorage().setItem(key, value);
    }
    function removeItem(key) {
      getStorage().removeItem(key);
    }
    function getItem(key, callback) {
      const value = getStorage().getItem(key);
      if (typeof Promise === "undefined" || // old browsers
      !(value instanceof Promise)) {
        callback(value);
      } else {
        value.then((id) => callback(id));
      }
    }
    var IndexedDBStorage = class {
      constructor() {
        this.dbPromise = new Promise((resolve) => {
          const request = indexedDB.open("_colyseus_storage", 1);
          request.onupgradeneeded = () => request.result.createObjectStore("store");
          request.onsuccess = () => resolve(request.result);
        });
      }
      tx(mode, fn) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          const db = yield this.dbPromise;
          const store = db.transaction("store", mode).objectStore("store");
          return fn(store);
        });
      }
      setItem(key, value) {
        return this.tx("readwrite", (store) => store.put(value, key)).then();
      }
      getItem(key) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          const request = yield this.tx("readonly", (store) => store.get(key));
          return new Promise((resolve) => {
            request.onsuccess = () => resolve(request.result);
          });
        });
      }
      removeItem(key) {
        return this.tx("readwrite", (store) => store.delete(key)).then();
      }
    };
    exports.getItem = getItem;
    exports.removeItem = removeItem;
    exports.setItem = setItem;
  }
});

// ../node_modules/colyseus.js/build/cjs/Auth.js
var require_Auth = __commonJS({
  "../node_modules/colyseus.js/build/cjs/Auth.js"(exports) {
    "use strict";
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var Storage = require_Storage();
    var nanoevents = require_nanoevents();
    var _Auth__initialized;
    var _Auth__initializationPromise;
    var _Auth__signInWindow;
    var _Auth__events;
    var Auth = class {
      constructor(http) {
        this.http = http;
        this.settings = {
          path: "/auth",
          key: "colyseus-auth-token"
        };
        _Auth__initialized.set(this, false);
        _Auth__initializationPromise.set(this, void 0);
        _Auth__signInWindow.set(this, void 0);
        _Auth__events.set(this, nanoevents.createNanoEvents());
        Storage.getItem(this.settings.key, (token) => this.token = token);
      }
      set token(token) {
        this.http.authToken = token;
      }
      get token() {
        return this.http.authToken;
      }
      onChange(callback) {
        const unbindChange = tslib.__classPrivateFieldGet(this, _Auth__events, "f").on("change", callback);
        if (!tslib.__classPrivateFieldGet(this, _Auth__initialized, "f")) {
          tslib.__classPrivateFieldSet(this, _Auth__initializationPromise, new Promise((resolve, reject) => {
            this.getUserData().then((userData) => {
              this.emitChange(Object.assign(Object.assign({}, userData), { token: this.token }));
            }).catch((e) => {
              this.emitChange({ user: null, token: void 0 });
            }).finally(() => {
              resolve();
            });
          }), "f");
        }
        tslib.__classPrivateFieldSet(this, _Auth__initialized, true, "f");
        return unbindChange;
      }
      getUserData() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          if (this.token) {
            return (yield this.http.get(`${this.settings.path}/userdata`)).data;
          } else {
            throw new Error("missing auth.token");
          }
        });
      }
      registerWithEmailAndPassword(email, password, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          const data = (yield this.http.post(`${this.settings.path}/register`, {
            body: { email, password, options }
          })).data;
          this.emitChange(data);
          return data;
        });
      }
      signInWithEmailAndPassword(email, password) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          const data = (yield this.http.post(`${this.settings.path}/login`, {
            body: { email, password }
          })).data;
          this.emitChange(data);
          return data;
        });
      }
      signInAnonymously(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          const data = (yield this.http.post(`${this.settings.path}/anonymous`, {
            body: { options }
          })).data;
          this.emitChange(data);
          return data;
        });
      }
      sendPasswordResetEmail(email) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          return (yield this.http.post(`${this.settings.path}/forgot-password`, {
            body: { email }
          })).data;
        });
      }
      signInWithProvider(providerName_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (providerName, settings = {}) {
          return new Promise((resolve, reject) => {
            const w = settings.width || 480;
            const h = settings.height || 768;
            const upgradingToken = this.token ? `?token=${this.token}` : "";
            const title = `Login with ${providerName[0].toUpperCase() + providerName.substring(1)}`;
            const url = this.http["client"]["getHttpEndpoint"](`${settings.prefix || `${this.settings.path}/provider`}/${providerName}${upgradingToken}`);
            const left = screen.width / 2 - w / 2;
            const top = screen.height / 2 - h / 2;
            tslib.__classPrivateFieldSet(this, _Auth__signInWindow, window.open(url, title, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left), "f");
            const onMessage = (event) => {
              if (event.data.user === void 0 && event.data.token === void 0) {
                return;
              }
              clearInterval(rejectionChecker);
              tslib.__classPrivateFieldGet(this, _Auth__signInWindow, "f").close();
              tslib.__classPrivateFieldSet(this, _Auth__signInWindow, void 0, "f");
              window.removeEventListener("message", onMessage);
              if (event.data.error !== void 0) {
                reject(event.data.error);
              } else {
                resolve(event.data);
                this.emitChange(event.data);
              }
            };
            const rejectionChecker = setInterval(() => {
              if (!tslib.__classPrivateFieldGet(this, _Auth__signInWindow, "f") || tslib.__classPrivateFieldGet(this, _Auth__signInWindow, "f").closed) {
                tslib.__classPrivateFieldSet(this, _Auth__signInWindow, void 0, "f");
                reject("cancelled");
                window.removeEventListener("message", onMessage);
              }
            }, 200);
            window.addEventListener("message", onMessage);
          });
        });
      }
      signOut() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          this.emitChange({ user: null, token: null });
        });
      }
      emitChange(authData) {
        if (authData.token !== void 0) {
          this.token = authData.token;
          if (authData.token === null) {
            Storage.removeItem(this.settings.key);
          } else {
            Storage.setItem(this.settings.key, authData.token);
          }
        }
        tslib.__classPrivateFieldGet(this, _Auth__events, "f").emit("change", authData);
      }
    };
    _Auth__initialized = /* @__PURE__ */ new WeakMap(), _Auth__initializationPromise = /* @__PURE__ */ new WeakMap(), _Auth__signInWindow = /* @__PURE__ */ new WeakMap(), _Auth__events = /* @__PURE__ */ new WeakMap();
    exports.Auth = Auth;
  }
});

// ../node_modules/colyseus.js/build/cjs/3rd_party/discord.js
var require_discord = __commonJS({
  "../node_modules/colyseus.js/build/cjs/3rd_party/discord.js"(exports) {
    "use strict";
    function discordURLBuilder(url) {
      var _a;
      const localHostname = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) || "localhost";
      const remoteHostnameSplitted = url.hostname.split(".");
      const subdomain = !url.hostname.includes("trycloudflare.com") && // ignore cloudflared subdomains
      !url.hostname.includes("discordsays.com") && // ignore discordsays.com subdomains
      remoteHostnameSplitted.length > 2 ? `/${remoteHostnameSplitted[0]}` : "";
      return url.pathname.startsWith("/.proxy") ? `${url.protocol}//${localHostname}${subdomain}${url.pathname}${url.search}` : `${url.protocol}//${localHostname}/.proxy/colyseus${subdomain}${url.pathname}${url.search}`;
    }
    exports.discordURLBuilder = discordURLBuilder;
  }
});

// ../node_modules/colyseus.js/build/cjs/Client.js
var require_Client = __commonJS({
  "../node_modules/colyseus.js/build/cjs/Client.js"(exports) {
    "use strict";
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var Errors = require_Errors();
    var Room = require_Room();
    var HTTP = require_HTTP();
    var Auth = require_Auth();
    var discord = require_discord();
    var _a;
    var MatchMakeError = class _MatchMakeError extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
        this.name = "MatchMakeError";
        Object.setPrototypeOf(this, _MatchMakeError.prototype);
      }
    };
    var DEFAULT_ENDPOINT = typeof window !== "undefined" && typeof ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) !== "undefined" ? `${window.location.protocol.replace("http", "ws")}//${window.location.hostname}${window.location.port && `:${window.location.port}`}` : "ws://127.0.0.1:2567";
    var Client = class {
      constructor(settings = DEFAULT_ENDPOINT, options) {
        var _a2, _b;
        if (typeof settings === "string") {
          const url = settings.startsWith("/") ? new URL(settings, DEFAULT_ENDPOINT) : new URL(settings);
          const secure = url.protocol === "https:" || url.protocol === "wss:";
          const port = Number(url.port || (secure ? 443 : 80));
          this.settings = {
            hostname: url.hostname,
            pathname: url.pathname,
            port,
            secure,
            searchParams: url.searchParams.toString() || void 0
          };
        } else {
          if (settings.port === void 0) {
            settings.port = settings.secure ? 443 : 80;
          }
          if (settings.pathname === void 0) {
            settings.pathname = "";
          }
          this.settings = settings;
        }
        if (this.settings.pathname.endsWith("/")) {
          this.settings.pathname = this.settings.pathname.slice(0, -1);
        }
        this.http = new HTTP.HTTP(this, (options === null || options === void 0 ? void 0 : options.headers) || {});
        this.auth = new Auth.Auth(this.http);
        this.urlBuilder = options === null || options === void 0 ? void 0 : options.urlBuilder;
        if (!this.urlBuilder && typeof window !== "undefined" && ((_b = (_a2 = window === null || window === void 0 ? void 0 : window.location) === null || _a2 === void 0 ? void 0 : _a2.hostname) === null || _b === void 0 ? void 0 : _b.includes("discordsays.com"))) {
          this.urlBuilder = discord.discordURLBuilder;
          console.log("Colyseus SDK: Discord Embedded SDK detected. Using custom URL builder.");
        }
      }
      joinOrCreate(roomName_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (roomName, options = {}, rootSchema) {
          return yield this.createMatchMakeRequest("joinOrCreate", roomName, options, rootSchema);
        });
      }
      create(roomName_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (roomName, options = {}, rootSchema) {
          return yield this.createMatchMakeRequest("create", roomName, options, rootSchema);
        });
      }
      join(roomName_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (roomName, options = {}, rootSchema) {
          return yield this.createMatchMakeRequest("join", roomName, options, rootSchema);
        });
      }
      joinById(roomId_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (roomId, options = {}, rootSchema) {
          return yield this.createMatchMakeRequest("joinById", roomId, options, rootSchema);
        });
      }
      /**
       * Re-establish connection with a room this client was previously connected to.
       *
       * @param reconnectionToken The `room.reconnectionToken` from previously connected room.
       * @param rootSchema (optional) Concrete root schema definition
       * @returns Promise<Room>
       */
      reconnect(reconnectionToken, rootSchema) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          if (typeof reconnectionToken === "string" && typeof rootSchema === "string") {
            throw new Error("DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\nYou can get this token from previously connected `room.reconnectionToken`");
          }
          const [roomId, token] = reconnectionToken.split(":");
          if (!roomId || !token) {
            throw new Error("Invalid reconnection token format.\nThe format should be roomId:reconnectionToken");
          }
          return yield this.createMatchMakeRequest("reconnect", roomId, { reconnectionToken: token }, rootSchema);
        });
      }
      consumeSeatReservation(response, rootSchema, reuseRoomInstance) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
          const room = this.createRoom(response.room.name, rootSchema);
          room.roomId = response.room.roomId;
          room.sessionId = response.sessionId;
          const options = { sessionId: room.sessionId };
          if (response.reconnectionToken) {
            options.reconnectionToken = response.reconnectionToken;
          }
          const targetRoom = reuseRoomInstance || room;
          room.connect(this.buildEndpoint(response.room, options, response.protocol), response.devMode && (() => tslib.__awaiter(this, void 0, void 0, function* () {
            console.info(`[Colyseus devMode]: ${String.fromCodePoint(128260)} Re-establishing connection with room id '${room.roomId}'...`);
            let retryCount = 0;
            let retryMaxRetries = 8;
            const retryReconnection = () => tslib.__awaiter(this, void 0, void 0, function* () {
              retryCount++;
              try {
                yield this.consumeSeatReservation(response, rootSchema, targetRoom);
                console.info(`[Colyseus devMode]: ${String.fromCodePoint(9989)} Successfully re-established connection with room '${room.roomId}'`);
              } catch (e) {
                if (retryCount < retryMaxRetries) {
                  console.info(`[Colyseus devMode]: ${String.fromCodePoint(128260)} retrying... (${retryCount} out of ${retryMaxRetries})`);
                  setTimeout(retryReconnection, 2e3);
                } else {
                  console.info(`[Colyseus devMode]: ${String.fromCodePoint(10060)} Failed to reconnect. Is your server running? Please check server logs.`);
                }
              }
            });
            setTimeout(retryReconnection, 2e3);
          })), targetRoom, response, this.http.headers);
          return new Promise((resolve, reject) => {
            const onError = (code, message) => reject(new Errors.ServerError(code, message));
            targetRoom.onError.once(onError);
            targetRoom["onJoin"].once(() => {
              targetRoom.onError.remove(onError);
              resolve(targetRoom);
            });
          });
        });
      }
      createMatchMakeRequest(method_1, roomName_1) {
        return tslib.__awaiter(this, arguments, void 0, function* (method, roomName, options = {}, rootSchema, reuseRoomInstance) {
          const response = (yield this.http.post(`matchmake/${method}/${roomName}`, {
            headers: {
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(options)
          })).data;
          if (response.error) {
            throw new MatchMakeError(response.error, response.code);
          }
          if (method === "reconnect") {
            response.reconnectionToken = options.reconnectionToken;
          }
          return yield this.consumeSeatReservation(response, rootSchema, reuseRoomInstance);
        });
      }
      createRoom(roomName, rootSchema) {
        return new Room.Room(roomName, rootSchema);
      }
      buildEndpoint(room, options = {}, protocol = "ws") {
        let searchParams = this.settings.searchParams || "";
        if (this.http.authToken) {
          options["_authToken"] = this.http.authToken;
        }
        for (const name in options) {
          if (!options.hasOwnProperty(name)) {
            continue;
          }
          searchParams += (searchParams ? "&" : "") + `${name}=${options[name]}`;
        }
        if (protocol === "h3") {
          protocol = "http";
        }
        let endpoint = this.settings.secure ? `${protocol}s://` : `${protocol}://`;
        if (room.publicAddress) {
          endpoint += `${room.publicAddress}`;
        } else {
          endpoint += `${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}`;
        }
        const endpointURL = `${endpoint}/${room.processId}/${room.roomId}?${searchParams}`;
        return this.urlBuilder ? this.urlBuilder(new URL(endpointURL)) : endpointURL;
      }
      getHttpEndpoint(segments = "") {
        const path = segments.startsWith("/") ? segments : `/${segments}`;
        let endpointURL = `${this.settings.secure ? "https" : "http"}://${this.settings.hostname}${this.getEndpointPort()}${this.settings.pathname}${path}`;
        if (this.settings.searchParams) {
          endpointURL += `?${this.settings.searchParams}`;
        }
        return this.urlBuilder ? this.urlBuilder(new URL(endpointURL)) : endpointURL;
      }
      getEndpointPort() {
        return this.settings.port !== 80 && this.settings.port !== 443 ? `:${this.settings.port}` : "";
      }
    };
    Client.VERSION = "0.16.22";
    exports.Client = Client;
    exports.MatchMakeError = MatchMakeError;
  }
});

// ../node_modules/colyseus.js/build/cjs/serializer/NoneSerializer.js
var require_NoneSerializer = __commonJS({
  "../node_modules/colyseus.js/build/cjs/serializer/NoneSerializer.js"(exports) {
    "use strict";
    var NoneSerializer = class {
      setState(rawState) {
      }
      getState() {
        return null;
      }
      patch(patches) {
      }
      teardown() {
      }
      handshake(bytes) {
      }
    };
    exports.NoneSerializer = NoneSerializer;
  }
});

// ../node_modules/colyseus.js/build/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/colyseus.js/build/cjs/index.js"(exports) {
    require_legacy();
    var Client = require_Client();
    var Protocol = require_Protocol();
    var Room = require_Room();
    var Auth = require_Auth();
    var Errors = require_Errors();
    var SchemaSerializer = require_SchemaSerializer();
    var NoneSerializer = require_NoneSerializer();
    var Serializer = require_Serializer();
    Serializer.registerSerializer("schema", SchemaSerializer.SchemaSerializer);
    Serializer.registerSerializer("none", NoneSerializer.NoneSerializer);
    exports.Client = Client.Client;
    exports.MatchMakeError = Client.MatchMakeError;
    Object.defineProperty(exports, "ErrorCode", {
      enumerable: true,
      get: function() {
        return Protocol.ErrorCode;
      }
    });
    Object.defineProperty(exports, "Protocol", {
      enumerable: true,
      get: function() {
        return Protocol.Protocol;
      }
    });
    exports.Room = Room.Room;
    exports.Auth = Auth.Auth;
    exports.ServerError = Errors.ServerError;
    exports.SchemaSerializer = SchemaSerializer.SchemaSerializer;
    exports.getStateCallbacks = SchemaSerializer.getStateCallbacks;
    exports.registerSerializer = Serializer.registerSerializer;
  }
});
export default require_cjs();
//# sourceMappingURL=colyseus__js.js.map
